/** ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename  : XFR1.C
**     Project   : TP1
**     Processor : 56F8367
**     Component : DSP_Func_XFR
**     Version   : Component 01.014, Driver 01.06, CPU db: 2.87.058
**     Compiler  : Metrowerks DSP C Compiler
**     Date/Time : 30/07/2015, 19:47
**     Abstract  :
**          The Digital Signal Processing Function Library implements
**          functions for matrices of fractional types as library routines.
**          The matrix operations provide highly optimized loops
**          on the elements of each matrix in order to provide the best
**          performance. The function library provides such matrix functions
**          for the 16-bit, (short), fractional type. For portability,
**          we have defined the short 16-bit fractional type as Frac16.
**     Settings  :
**          Bean Name                      : XFR1
**          Use Assembler Files            : no
**          Array Library                  : AFR1
**     Contents  :
**         xfr16Add   - void XFR1_xfr16Add(Frac16 *pX, int rows, int cols, Frac16 *pY, Frac16 *pZ);
**         xfr16Sub   - void XFR1_xfr16Sub(Frac16 *pX, int rows, int cols, Frac16 *pY, Frac16 *pZ);
**         xfr16Mult  - void XFR1_xfr16Mult(Frac16 *pX, int xrows, int xcols, Frac16 *pY, int ycols,...
**         xfr16Equal - bool XFR1_xfr16Equal(Frac16 *pX, int rows, int cols, Frac16 *pY);
**         xfr16Trans - void XFR1_xfr16Trans(Frac16 *pX, int xrows, int xcols, Frac16 *pZ);
**         xfr16Inv   - Frac32 XFR1_xfr16Inv(Frac16 *pX, int rowscols, Frac16 *pZ);
**         xfr16Det   - Frac32 XFR1_xfr16Det(Frac16 *pX, int rowscols);
**
**     (c) Freescale Semiconductor
**     2004 All Rights Reserved
**
**     Copyright : 1997 - 2009 Freescale Semiconductor, Inc. All Rights Reserved.
**     
**     http      : www.freescale.com
**     mail      : support@freescale.com
** ###################################################################*/

/* MODULE XFR1. */

#include "XFR1.h"
#include "assert.h"

/*
** ===================================================================
**     Method      :  XFR1_xfr16Sub (component DSP_Func_XFR)
**
**     Description :
**         The function subtracts the input matrix Y from the input
**         matrix X, producing the output matrix Z; i.e., Z = X - Y.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * pX              - Pointer to the first input matrix X of
**                           fractional data values.
**         rows            - The number of rows of the input
**                           matrix X; this is also the number of
**                           rows of the input matrix Y.
**         cols            - The number of columns of the input
**                           matrix X; this is also the number of
**                           columns of the input matrix Y.
**       * pY              - Pointer to the second input matrix Y of
**                           fractional data values.
**       * pZ              - Pointer to the output matrix Z of
**                           fractional data values.
**     Returns     : Nothing
** ===================================================================
*/
/*
void XFR1_xfr16Sub(Frac16 *pX,int rows,int cols,Frac16 *pY,Frac16 *pZ)
{
**     This method is implemented as macro      **
}
*/

/*
** ===================================================================
**     Method      :  XFR1_xfr16Add (component DSP_Func_XFR)
**
**     Description :
**         The function totals two matrices, X and Y, to produce Z:
**         Z = X + Y.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * pX              - Pointer to an input matrix (X) of
**                           fractional data values.
**         rows            - The number of rows in the matrices X,
**                           Y, and Z.
**         cols            - The number of columns in the matrices
**                           X, Y, and Z.
**       * pY              - Pointer to an input matrix (Y) of
**                           fractional data values.
**       * pZ              - Pointer to an output matrix (Z) of
**                           fractional data values.
**     Returns     : Nothing
** ===================================================================
*/
/*
void XFR1_xfr16Add(Frac16 *pX,int rows,int cols,Frac16 *pY,Frac16 *pZ)
{
**     This method is implemented as macro      **
}
*/

/*
** ===================================================================
**     Method      :  XFR1_xfr16Mult (component DSP_Func_XFR)
**
**     Description :
**         The function multiplies the input matrix X by the input
**         matrix Y to produce output matrix Z.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * pX              - Pointer to the first input matrix X of
**                           fractional data values.
**         xrows           - The number of rows of the input
**                           matrix X.
**         xcols           - The number of columns of the input
**                           matrix X; this is also the number of
**                           rows of the input matrix Y.
**       * pY              - Pointer to the second input matrix Y of
**                           fractional data values.
**         ycols           - The number of columns of the input
**                           matrix Y.
**       * pZ              - Pointer to the output matrix Z of
**                           fractional data values.
**     Returns     : Nothing
** ===================================================================
*/
void xfr16Mult(Frac16 *pX,int xrows,int xcols,Frac16 *pY,int ycols,Frac16 *pZ)
{
  int      i, j, k;
  Frac16  *pXelem;
  Frac16  *pYelem;
  Frac32   temp;

  for (i=0; i<xrows; i++) {
    for (j=0; j<ycols; j++) {
      pXelem = pX;
      pYelem = pY + j;
      temp   = 0;
      for (k=0; k<xcols; k++) {
        temp = L_mac (temp, *pXelem, *pYelem);
        pXelem++;
        pYelem += ycols;
      }
      *pZ++ = round(temp);
    }
    pX += xcols;
  }
}

/*
** ===================================================================
**     Method      :  XFR1_xfr16Equal (component DSP_Func_XFR)
**
**     Description :
**         The function determines whether two matrices are equal.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * pX              - Pointer to the first input matrix X of
**                           fractional data values.
**         rows            - The number of rows of the input
**                           matrices X and Y.
**         cols            - The number of columns of the input
**                           matrices X and Y.
**       * pY              - Pointer to the second input matrix Y of
**                           fractional data values.
**     Returns     :
**         ---             - The function returns true if all
**                           corresponding elements of the two input
**                           matrices are equal. If any element of X
**                           differs in value from the corresponding
**                           element of Y, equal will return false.
** ===================================================================
*/
/*
bool XFR1_xfr16Equal(Frac16 *pX,int rows,int cols,Frac16 *pY)
{
**     This method is implemented as macro      **
}
*/

/*
** ===================================================================
**     Method      :  XFR1_xfr16Trans (component DSP_Func_XFR)
**
**     Description :
**         The function transposes the input matrix X and produces
**         the output matrix Z.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * pX              - Pointer to the input matrix X of
**                           fractional data values.
**         xrows           - The number of rows of the input
**                           matrix X; this is also the number of
**                           columns of the output matrix Z.
**         xcols           - The number of columns of the input
**                           matrix Y; this is also the number of
**                           rows of the output matrix Z.
**       * pZ              - Pointer to the output matrix Z of
**                           fractional data values.
**     Returns     : Nothing
** ===================================================================
*/
void xfr16Trans(Frac16 *pX,int xrows,int xcols,Frac16 *pZ)
{
  int      i, j;
  Frac16 * pZtemp;

  for (i=0; i<xrows; i++) {
    pZtemp = pZ++;
    for (j=0; j<xcols; j++) {
      *pZtemp = *pX++;
      pZtemp += xrows;
    }
  }
}

/*
** ===================================================================
**     Method      :  XFR1_xfr16Inv (component DSP_Func_XFR)
**
**     Description :
**         The function calculates the inverse matrix Z of the
**         square input matrix X.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * pX              - Pointer to a square input matrix X of
**                           fractional data values.
**         rowscols        - The number of rows and
**                           columns of the square input matrix X.
**       * pZ              - Pointer to a square output matrix Z of
**                           fractional data values.
**     Returns     :
**         ---             - The function stores the inverse matrix
**                           in the matrix pointed to by pZ. The inv
**                           function returns the value of the
**                           determinant of the matrix X.
** ===================================================================
*/
Frac32 xfr16Inv(Frac16 *pX,int rowscols,Frac16 *pZ)
{
  Frac16 *px_tmp;
  Frac32 acca, accb;

  acca = xfr16Det( pX, rowscols );
  if( acca == 0 )  return (0);         /* determinant is equal to 0 => exit from routine */
  /* determinant != 0 => continue */
  switch( rowscols ) {
  case 2:
        pX += 3;                       /*  pX-> a22                 */
        *pZ++ = *pX;                   /*  A11 = a22                */
        pX -= 2;                       /*  pX-> a12                 */
        *pZ++ = negate( *pX++ );       /*  A12 = -a12 , pX-> a21    */
        *pZ++ = negate( *pX );         /*  A21 = -a21               */
        pX -= 2;                       /*  pX-> a11                 */
        *pZ = *pX;                     /*  A22 = a11                */
        break;
  case 3:
        pX += 4;
        px_tmp = pX + 4;
        accb = L_mult( *pX++, *px_tmp-- ); /*  a22*a33 - a23*a32         */
        *pZ++ = msu_r( accb, *pX, *px_tmp++ );
        //*pZ++ = extract_l( L_msu( accb, *pX, *px_tmp++ ) );
        pX -= 4;
        accb = L_mult( *pX++, *px_tmp-- ); /*  a12*a33 - a13*a32         */
        *pZ++ = negate( msu_r( accb, *pX--, *px_tmp ) );
        //*pZ++ = negate( extract_l( L_msu( accb, *pX--, *px_tmp )) );
        px_tmp -= 2;
        accb = L_mult( *pX++, *px_tmp-- ); /*  a12*a23 - a13*a22         */
        *pZ++ = msu_r( accb, *pX, *px_tmp-- );
        //*pZ++ = extract_l( L_msu( accb, *pX, *px_tmp-- ) );
        pX += 6;
        accb = L_mult( *pX, *px_tmp ); /*  a33*a21 - a31*a23         */
        pX -= 2;
        px_tmp += 2;
        *pZ++ = negate( msu_r( accb, *pX, *px_tmp ) );
        //*pZ++ = negate( extract_l( L_msu( accb, *pX, *px_tmp )) );
        pX += 2;
        px_tmp -= 5;
        accb = L_mult( *pX, *px_tmp ); /*  a33*a11 - a31*a13         */
        pX -= 2;
        px_tmp += 2;
        *pZ++ = msu_r( accb, *pX--, *px_tmp );
        //*pZ++ = extract_l( L_msu( accb, *pX--, *px_tmp ) );
        px_tmp -= 2;
        accb = L_mult( *pX, *px_tmp ); /*  a23*a11 - a21*a13         */
        pX -= 2;
        px_tmp += 2;
        *pZ++ = negate( msu_r( accb, *pX, *px_tmp ) );
        //*pZ++ = negate( extract_l( L_msu( accb, *pX, *px_tmp )) );
        px_tmp += 5;
        accb = L_mult( *pX++, *px_tmp-- ); /*  a21*a32 - a22*a31         */
        *pZ++ = msu_r( accb, *pX, *px_tmp++ );
        //*pZ++ = extract_l( L_msu( accb, *pX, *px_tmp++ ) );
        pX -= 4;
        accb = L_mult( *pX++, *px_tmp-- ); /*  a11*a32 - a12*a31         */
        *pZ++ = negate( msu_r( accb, *pX--, *px_tmp ) );
        //*pZ++ = negate( extract_l( L_msu( accb, *pX--, *px_tmp ) ));
        px_tmp -= 2;
        accb = L_mult( *pX++, *px_tmp-- ); /*  a11*a22 - a12*a21         */
        *pZ++ = msu_r( accb, *pX, *px_tmp );
        //*pZ++ = extract_l( L_msu( accb, *pX, *px_tmp ) );
        break;
  }
  return( acca );
}

/*
** ===================================================================
**     Method      :  XFR1_xfr16Det (component DSP_Func_XFR)
**
**     Description :
**         The function calculates the determinant of the square
**         input matrix X.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * pX              - Pointer to the square input matrix of
**                           fractional data values.
**         rowscols        - The number of rows of the
**                           square input matrix; this is also the
**                           number of columns of the square input
**                           matrix.
**     Returns     :
**         ---             - The function returns the results of the
**                           determinant calculation as the return
**                           value for the function.
** ===================================================================
*/
Frac32 xfr16Det(Frac16 *pX,int rowscols)
{
  Frac16 *px_tmp, *px_tmp2;
  Frac32 acca, accb;

  assert (rowscols <= 3);
  assert (rowscols >= 2);
  switch ( rowscols ) {
  case 2:
        px_tmp = pX + 3;               /*  pX->a11 , px_tmp->a22 */
        acca = L_mult( *pX++, *px_tmp-- ); /*  acca = a11*a22 , pX->a12 , px_tmp->a21 */
        acca = L_msu( acca, *pX, *px_tmp ); /*  acca = acca - a12*a21 */
        break;
  case 3:
        px_tmp = pX + 4;               /*  pX->a11, px_tmp->a22 */
        /* px_tmp2 = pX + 8;  */       /*  px_tmp2->a33 */
        px_tmp2 = px_tmp + 4;
        acca = L_mult( *pX++, *px_tmp++ ); /*  a11*a22*a33 */
        acca = L_mult_ls( acca, *px_tmp2 );
        px_tmp2 -= 2;
        accb = L_mult( *pX++, *px_tmp ); /*  a12*a23*a31 */
        px_tmp -= 2;
        accb = L_mult_ls( accb, *px_tmp2++ );
        acca = L_add( acca, accb );
        accb = L_mult( *pX, *px_tmp++ ); /*  a13*a21*a32 */
        accb = L_mult_ls( accb, *px_tmp2-- );
        acca = L_add( acca, accb );
        accb = L_mult( *pX, *px_tmp++ ); /*   - a13*a22*a31 */
        pX -= 2;
        accb = L_mult_ls( accb, *px_tmp2++ );
        acca = L_sub( acca, accb );
        accb = L_mult( *pX++, *px_tmp ); /*  - a11*a23*a32 */
        px_tmp -= 2;
        accb = L_mult_ls( accb, *px_tmp2++ );
        acca = L_sub( acca, accb );
        accb = L_mult( *pX, *px_tmp ); /*  - a12*a21*a33 */
        accb = L_mult_ls( accb, *px_tmp2 );
        acca = L_sub( acca, accb );
        break;
  }
  return( acca );
}

/* END XFR1. */

/*
** ###################################################################
**
**     This file was created by Processor Expert 3.00 [04.35]
**     for the Freescale 56800 series of microcontrollers.
**
** ###################################################################
*/
